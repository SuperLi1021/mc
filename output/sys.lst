C51 COMPILER V9.01   SYS                                                                   08/24/2021 13:50:09 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE SYS
OBJECT MODULE PLACED IN ..\output\sys.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\user\sys\sys.c BROWSE INCDIR(C:\Keil_v5\C51\INC;C:\Keil_v5\C51\INC) DEBU
                    -G OBJECTEXTEND PRINT(..\output\sys.lst) OBJECT(..\output\sys.obj)

line level    source

   1          /*********************************************************************/
   2          /*公司名称： 深圳市朗科智能电气股份有限公司                          */
   3          /*模 块 名： 系统模块                                                */
   4          /*创 建 人： LICHAOFAN     日期：2021-08-13                          */
   5          /*修 改 人： LICHAOFAN     日期：2021-08-13                          */
   6          /*功能描述： 提供定时，延时，信号抓取，信号处理                                  */
   7          /*其他说明：                                                         */
   8          /*版本：                                                             */
   9          /*********************************************************************/
  10          
  11          
  12          
  13          
  14          //输出 P05    过零P00 红外P04开关 p10
  15          
  16          #include <SN8F5702.h>
  17          /********************************定义全局位变量***********************/
  18          bit PinFlag;
  19          
  20          /********************************定义全局字节变量*********************/
  21          extern unsigned int PinT;
  22          extern unsigned char Level,PinBit,SWFlag,HWFlag,sw;
  23          
  24          /*********************************************************************
  25          * 函 数 名： InitT0T1
  26          * 功能描述： 对定时器初始化
  27          * 函数说明： 定时器初始化函数
  28          * 调用函数： 
  29          * 全局变量：
  30          * 输 入： 无
  31          * 返 回： 无
  32          * 设 计 者：LICHAOFAN 日期：2021-08-13
  33          * 修 改 者：LICHAOFAN 日期：2021-08-13
  34          /*版本：
  35          /**********************************************************************/
  36          void InitT0T1(void)
  37          {       
  38   1              TH1   = 0x9b;                              //装入初值
  39   1              TL1   = 0x9b;
  40   1              TH0   = 0x9B;                                    //装入初值
  41   1              TL0   = 0x9B;
  42   1              TMOD  = 0x66;                                    //使用T0 T1 自动装填模式
  43   1              TCON0 = 0x22;                                    //外分频控制 /32
  44   1              TCON  = 0x50;                                    //启动定时器T0 T1 的功能控制位
  45   1              IEN0  = 0x8A;                                    //使能中断
  46   1      }
  47          
  48          
  49          /*********************************************************************
  50          * 函 数 名： InitT2
  51          * 功能描述： 对定时器t2初始化
  52          * 函数说明： 定时器t2初始化函数
  53          * 调用函数： 
  54          * 全局变量：
C51 COMPILER V9.01   SYS                                                                   08/24/2021 13:50:09 PAGE 2   

  55          * 输 入： 无
  56          * 返 回： 无
  57          * 设 计 者：LICHAOFAN 日期：2021-08-16
  58          * 修 改 者：LICHAOFAN 日期：2021-08-16
  59          /*版本：
  60          /**********************************************************************/
  61          void InitT2(void)
  62          {       
  63   1              TH2 = 0xE5;                                             //定时2.5ms
  64   1              TL2 = 0xF5;
  65   1              T2CON = 0x00;
  66   1              IEN0 |= 0xA0;                                   //使能T2中断
  67   1      
  68   1      }                        
  69          /*********************************************************************
  70          * 函 数 名： T2Interrupt
  71          * 功能描述： 输出2.5ms低电平
  72          * 函数说明： T2中断处理函数
  73          * 调用函数： 
  74          * 全局变量：
  75          * 输 入： 无
  76          * 返 回： 无
  77          * 设 计 者：LICHAOFAN 日期：2021-08-13
  78          * 修 改 者：LICHAOFAN 日期：2021-08-13
  79          /*版本：
  80          /**********************************************************************/
  81          void T2Interrupt(void) interrupt ISRTimer2
  82          {       static bit MotorFlag;
  83   1              TH2 = 0xE5;                                                                                     //重装初值
  84   1              TL2 = 0xF5;
  85   1         
  86   1             IRCON &= 0xBF;                                                                   // TF2清零
  87   1      
  88   1                      if(MotorFlag==0)
  89   1                      {                               
  90   2                              P05=1;                                                                          //输出2.5ms低电平
  91   2                              MotorFlag=1;
  92   2                          return;
  93   2                      }
  94   1                              
  95   1                      if(MotorFlag==1)                                                                //输出完毕，关闭定时器2
  96   1                      {
  97   2                              MotorFlag=0;    
  98   2                              P05=0;
  99   2                              T2CON =0x00;
 100   2                      return;
 101   2                      }
 102   1         
 103   1      }
 104          /*********************************************************************
 105          * 函 数 名： T1Interrupt
 106          * 功能描述： 抓取信号中单个bit
 107          * 函数说明： T1中断处理函数
 108          * 调用函数： 
 109          * 全局变量： PinBit，PinFlag
 110          * 输 入： 无
 111          * 返 回： 无
 112          * 设 计 者：LICHAOFAN 日期：2021-08-13
 113          * 修 改 者：LICHAOFAN 日期：2021-08-13
 114          /*版本：
 115          /**********************************************************************/
 116          void T1Interrupt(void) interrupt ISRTimer1 
C51 COMPILER V9.01   SYS                                                                   08/24/2021 13:50:09 PAGE 3   

 117          {               
 118   1              /********************************定义字节变量***********************/
 119   1                      static unsigned char i,PinH,PinL;
 120   1                      unsigned char j,bitl,bith;
 121   1                      i++;
 122   1      
 123   1              if(i<10)                                                                                                                //每100us取一次值，比较高低电平的数量
 124   1              {
 125   2                      for(j=0;j<5;j++)
 126   2                      {       _nop_();_nop_();
 127   3                              if((P0&0x10)==0X10)     
 128   3                              {
 129   4                                                                                                                              //取值
 130   4                                      bith++;
 131   4                              }
 132   3                      else
 133   3                              bitl++;
 134   3                      }
 135   2                      if(bitl>bith)
 136   2                      {
 137   3                              PinL++;
 138   3                      }
 139   2                      else
 140   2                              PinH++;
 141   2                      bith=0;
 142   2                      bitl=0;
 143   2              }
 144   1              else
 145   1              {
 146   2                      i=0;
 147   2                      if(PinH>PinL)                                                                                   //高电平多则该BIT为1
 148   2                      {
 149   3                              PinBit=1;
 150   3                //  P00=1;
 151   3              }
 152   2                      else                                                                                                                    //反之为0
 153   2                      {
 154   3                              PinBit=0;
 155   3              //      P00=0;
 156   3                      }
 157   2                      PinH=0;                                                                                                         //对计数值清零，将获取成功标志位置1，关闭定时器1
 158   2                      PinL=0;
 159   2                      PinFlag=1;
 160   2                      TR1=0;
 161   2              }
 162   1              
 163   1         
 164   1      }
 165          /*********************************************************************
 166          * 函 数 名： T0Interrupt
 167          * 功能描述： 定时100us，抓取信号跳变，选择t1开启时间，对信号进行处理
 168          * 函数说明： T0中断处理函数
 169          * 调用函数： 
 170          * 全局变量：  PinBit，PinFlag，PinT
 171          * 输 入： 无
 172          * 返 回： 无
 173          * 设 计 者：LICHAOFAN 日期：2021-08-16
 174          * 修 改 者：LICHAOFAN 日期：2021-08-16
 175          /*版本：
 176          /**********************************************************************/
 177          void T0Interrupt(void) interrupt ISRTimer0 
 178          {               /********************************定义字节变量***********************/
C51 COMPILER V9.01   SYS                                                                   08/24/2021 13:50:09 PAGE 4   

 179   1          static      unsigned int PinData,DataError,PinOld,HWTimes,PinT1;
 180   1          static      unsigned char DataF,TIME,P07Old,P07Time,ZeroOld;
 181   1              
 182   1          /********************************定义位变量*************************/
 183   1          static  bit P07Flag,delaytime;
 184   1          TIME++;
 185   1          if(TIME>=100)
 186   1          {TIME=0;
 187   2         // P00=~P00;
 188   2         }                                                                                                            //模拟过零信号
 189   1      
 190   1      
 191   1      
 192   1      
 193   1          if((P0&0X10)!=ZeroOld)                                                                                      //抓取p04下降沿
 194   1              {       _nop_(); _nop_(); 
 195   2                       if((P0&0X10)!=ZeroOld)                                                                                 //抓取p04下降沿
 196   2                      {
 197   3                               
 198   3      
 199   3                              delaytime=1;
 200   3                         if((P0&0X10)==0)                                                                     //若有则接收到红外信号，取下降沿作为触发
 201   3                      {
 202   4                      
 203   4                              TR1=1;                                                                                                  //若抓到下降沿，则打开t1定时器获取数据
 204   4                                      DataF++;
 205   4                                              
 206   4                              }
 207   3                              DataError=0;                                                                                                    
 208   3                          ZeroOld=(P0&0x10);  
 209   3                      }  
 210   2                }
 211   1              else if(delaytime==1)
 212   1              DataError++;     
 213   1          if(DataError==600)                                                                                          //当6ms没有收到红外信号，就认为此轮信号接收完成
 214   1          {
 215   2                      //      DataError=0;                                                                                    //对计数值清零
 216   2                      DataF=0;
 217   2                      HWTimes++;
 218   2          }
 219   1         
 220   1          if(DataError==1500)                                                                                         //当15ms未收到红外信号，认为该次按键结束
 221   1              {   delaytime=0;
 222   2                      DataError=0;
 223   2                      HWFlag=1;
 224   2              }
 225   1           
 226   1           
 227   1           
 228   1           
 229   1          if(DataF>=1)                                                                                                                //读取信号
 230   1              {
 231   2                                      
 232   2                                      if(PinFlag==1)                                                                                  //当有信号bit被完全获取
 233   2                                      {       
 234   3                                                                PinFlag=0;
 235   3                                                                PinData=(PinData<<1)+PinBit;                          //记录
 236   3                                                      if(DataF==12)                                                                   //当其为最后一位时
 237   3                                                      {  
 238   4                                                                      if(PinOld==PinData)                                             //与上一次收到的值进行比较
 239   4                                                                      {   
 240   5                                                                              PinFlag=0;
C51 COMPILER V9.01   SYS                                                                   08/24/2021 13:50:09 PAGE 5   

 241   5                                                                           PinT1=PinData;
 242   5                                                                      PinData=0;
 243   5                                                                      }
 244   4                                                                      else                                                                    //否则记录下该值
 245   4                                                                              PinOld=PinData;
 246   4                                                                      PinData=0;
 247   4                                                              DataF=0;
 248   4                                                              PinFlag=0;
 249   4                                                              
 250   4                                                      } 
 251   3                                                      
 252   3                                      }
 253   2      
 254   2                      }
 255   1      
 256   1                      if((P0&0X01)!=P07Old)                                                                                   //抓取过零信号
 257   1                      {  
 258   2                              _nop_(); _nop_();
 259   2                              if((P0&0X01)!=P07Old)                                                                                   //抓取过零信号
 260   2                              {  
 261   3                                 P07Flag=1;
 262   3                              
 263   3                                  P07Old=(P0&0x01);
 264   3                      }
 265   2                      }
 266   1                      if(P07Flag==1)                                                                                                  //当有过零时 计数加一
 267   1                      {   
 268   2                              P07Time++;
 269   2                      
 270   2                      }
 271   1                      if(P07Time>=Level)                                                                                              //当计数值大于规定值时，打开T2计时器，输出2.5ms的低电平
 272   1                      {       
 273   2                              if(SWFlag==1)                                                                                           //当两个开关均打开时再开启定时器2输出
 274   2                  {   
 275   3                                      TH2 = 0xFF;
 276   3                                  TL2 = 0xFE;
 277   3                                  T2CON =0x01;
 278   3                        
 279   3                  }
 280   2                              P07Time=0;
 281   2                              P07Flag=0;
 282   2                                      
 283   2                      }
 284   1              if(HWFlag==1)                                                                                           //当按键已经结束时，将读取的值传出去
 285   1                      {
 286   2                          sw=1;                                                                                                       //通知主函数该次按键结束
 287   2                          HWFlag=0;                                                                                           //按键结束标志
 288   2                              PinT=PinT1;                                                                                             //传至主函数
 289   2                  PinT1=0x00;
 290   2                      }
 291   1      
 292   1                      
 293   1                
 294   1      }
 295            
 296          /*********************************************************************
 297          * 函 数 名： Delay100us
 298          * 功能描述： 提供100us延时
 299          * 函数说明： 延时函数
 300          * 调用函数： _nop_()
 301          * 全局变量：
 302          * 输 入： unsigned int n
C51 COMPILER V9.01   SYS                                                                   08/24/2021 13:50:09 PAGE 6   

 303          * 返 回： 无
 304          * 设 计 者：LICHAOFAN 日期：2021-08-13
 305          * 修 改 者：LICHAOFAN 日期：2021-08-13
 306          /*版本：
 307          /**********************************************************************/
 308          void Delay100us(unsigned char n)
 309          {
 310   1          unsigned char i, j;
 311   1          i = 0;
 312   1          j = 0;
 313   1          for (i=0; i<n; i++) 
 314   1          {
 315   2              for (j=0; j<2; j++) 
 316   2              {
 317   3                       _nop_(); _nop_();  _nop_(); _nop_();
 318   3                               _nop_();  _nop_(); _nop_(); _nop_();
 319   3              }
 320   2          }
 321   1      }
 322          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    476    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
